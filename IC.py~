# -*- coding: utf-8 -*-


"""Dans ce fichier, nous voulons implémenté le modèle IC"""

import numpy as np
from collections import defaultdict


def loadEpisodes(fichier):
    """ Loads episodes in arrays """
    
    # Load the file
    with open(fichier, 'r') as f:
        episodes = []
        for episode in f.readlines():                                           # Read lines one by one
            episode = np.array([p.split(':')                                    # Remove the last ';' and split':'
                                for p in episode[:-2].split(';')], float)
            episode = np.array(episode, int)
            episode = episode[episode[:,1].argsort()]                           # Sort the array in order of the 
            episodes.append(episode)                                            # infection time 
        
    return episodes       
    
    
class IC():
    def __init__(self, episodes, nbIteration=1):
        """ """
        
        self.episodes = episodes                                                # Array of episodes
        self.nbUser = max([max(epi[:,0]) for epi in self.episodes])             # Nomber of users or distincts nodes
        self.predecesseurs = defaultdict(dict)                                  # Dictionary of predecessors for each user
        self.successeurs = defaultdict(dict)                                    # Dictionary of successors for each user
        self.dMoins = dict()                                                    # Set of episodes D-
        self.dPlus = {(i,j):[] for i in range(0,self.nbUser)                    # Set of episodes D+
                      for j in range(0, self.nbUser)}   
        self.theta = np.array([[ np.random.random()                             # Probability of the precedent step ô
                                for i in range(0, self.nbUser)]             
                               for j in range(0, self.nbUser)])
        
    
    def createGraph(self):
        """ Creates the graph (tree) of episodes"""
        
        for episode in self.episodes:
            listeSuccesseurs = [episode[episode[:,1] > episode[i,1]][:,0]       # List of list of successors for each user
                                for i in range(len(episode))]   
            for i, successeur in enumerate(listeSuccesseurs):                   # for the list of successors of each user
                for v in successeur:                                            # for every successor of a user
                    u, proba = episode[i,0], np.random.random()                 # Generate a probability so within (0,1)
                    self.successeurs[u][v] = proba                              # u ---(proba)---> v 
                    self.predecesseurs[v][u] = proba                            # v ---(proba)---> u
        print(self.successeurs)
        
    def ptD(self):
        """ Estimates each success probability """
        
        p = dict()
        for episode in self.episodes:
            users, tempsU = episode[:,0], np.unique(episode[:,1])               # List of users of an episode and distinct
            p[d] = np.ones(self.nbUser)                                         # time
            for t in range(1,tempsU):                                           # For each time tU of the episode D
                ptd, hasPred = 1., False
                for user in users:
                    predU = episode[episode[:,1] < tempsU[t]][:,0]              # List of predecessors of user u at time tU
                    for v in predU:
                        if v in self.predecesseurs[user]:
                            ptd *= (1 - self.theta[v][user])
                            hasPred = True
                    if hasPred:
                        p[d][u] = 1-ptd
        return p
                    
        
    
    def setOfdPlus(self):
        """ This method fills the set of episodes D+ which satisfies
            both u € D(t) and v € D(>t) """
        
        for d, episode in enumerate(self.episodes):
            for i in range(0,len(episode)):
                for j in range(0,len(episode)):
                    u, v = episode[i][0], episode[j][0]
                    tu, tv = episode[i][1], episode[j][1]
                    if u == v:                                                  # If its the same user,
                        continue                                                # Do nothing                     
                    elif tv > tu:                                               # elif v is infected after u
                        self.dPlus[u,v].append(d)                               # append v in the dico dPlus
          
    
    def setOfdMoins(self):
        """ This method fills the set of episodes D- which satisfies
            both u € D(t) and v not € D(t) """
        
        for episode in self.episodes:
            for i in range(0,len(episode)):
                for j in range(0,100):
                    if (j not in episode[:,0]):
                        self.dmoinsDico[episode[i][0]][j] += 1
                        
    
    def fit(self):
        """ Estimates each diffusion probability """
        
        self.createGraph()
        self.dplus()
        self.dmoins()
        
        for i in range(0,self.nbIter):
            
            p = self.pdtu()
            
            for u in range(0,100):
                for v in range(0,100):
                    sommeOP = 0
                    for d in self.dplusDico[u,v]:
                        sommeOP += self.theta[u][v]/p[d][v]
                    self.theta[u][v] = sommeOP/(len(self.dplusDico[u,v]) + self.dmoinsDico[u][v])
                    
                    
                    
                
ic = IC(loadEpisodes("cascades_train.txt"))
ic.createGraph()
#ic.initTheta()